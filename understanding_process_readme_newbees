mcp-k8s-server – Newbie Guide (Go Edition)

Purpose (What this project does)
- This is a local MCP (Model Context Protocol) server that lets tools like GitHub Copilot talk to your Kubernetes cluster in a safe, controlled way.
- It exposes read-mostly tools (list pods, get logs, describe-like info) and opt-in write tools (apply/delete resources, set secrets, exec) guarded by:
  - Read-only toggle
  - Namespace and kind allowlists
  - Dry-run by default for mutations

High-level Architecture (How it’s wired)
- MCP transport: JSON-RPC 2.0 over stdio using LSP-style framing (Content-Length headers). Logs go to stderr.
- Server core: Minimal MCP server in Go that implements initialize, tools/list, tools/call and dispatches to a tool registry.
- Kubernetes access: client-go typed clients (CoreV1, etc.) and dynamic client + RESTMapper for generic GVK operations (including CRDs).
- Authz & safety: read-only mode, namespace/kind allowlists, and a simple per-tool rate limiter.

Where things live (Project structure)
- cmd/server/main.go – Entrypoint. Creates logger, loads Kubernetes clients, registers tools, runs stdio server, graceful shutdown.
- pkg/mcp – Protocol logic (framed stdio transport, JSON-RPC types, tool registry, built-ins).
- pkg/k8s – Kubernetes client loader and helpers (logs, dynamic discovery, YAML to unstructured).
- internal/authz – Safety/authorization controls (read-only, allowlists, rate limiting).
- internal/tools – Tool groups:
  - cluster.go – cluster.health, cluster.listContexts, cluster.setContext, ns.listNamespaces
  - workloads.go – pods.listPods, pods.get, pods.logs, pods.exec
  - resources.go – resources.get/apply/delete (SSA)
  - secrets.go – secrets.get/set (values redacted unless allowed)
- examples/* – Sample deployment and MCP client config.

Key packages (and why)
- client-go: Official Kubernetes Go client for typed APIs, discovery, exec/logs, and dynamic resources.
- log/slog: Structured logging to stderr to avoid corrupting the MCP stdout stream.

How requests flow
1) MCP client sends a framed JSON-RPC request (e.g., initialize, tools/list, tools/call).
2) pkg/mcp parses, dispatches to the Registry.
3) A tool handler in internal/tools validates inputs (lightweight), enforces authz, calls client-go.
4) Results are serialized to compact JSON and returned as MCP text content.

Safety model in practice
- Read-only mode (MCP_K8S_READONLY=true) blocks mutating tools: resources.apply, resources.delete, secrets.set, pods.exec.
- Namespace/kind allowlists further restrict writes.
- Mutations default to dry-run; set dryRun=false to persist intentionally.
- Secrets values are never logged and are redacted unless explicitly allowed.

Build and run (local)
```bash
# Build
go build -o bin/mcp-server ./cmd/server

# Run
KUBECONFIG=/absolute/path/to/kubeconfig \
K8S_CONTEXT=$(kubectl config current-context) \
K8S_NAMESPACE=default \
MCP_K8S_READONLY=true \
LOG_LEVEL=info \
./bin/mcp-server
```

Connect from GitHub Copilot MCP
- Edit ~/.copilot/mcp.json:
```json
{
  "mcpServers": {
    "k8s-local": {
      "command": "/absolute/path/to/mcp-k8s-server/bin/mcp-server",
      "args": [],
      "env": {
        "KUBECONFIG": "/home/user/.kube/config",
        "K8S_CONTEXT": "your-context",
        "K8S_NAMESPACE": "default",
        "MCP_K8S_READONLY": "true"
      }
    }
  }
}
```

Tool reference (concise)
- cluster.health → { status, clusterVersion, timestamp }
- cluster.listContexts → { current, contexts[] }
- cluster.setContext({ context }) → { current }
- ns.listNamespaces({ limit? }) → { namespaces[] }

- pods.listPods({ namespace?, labelSelector?, fieldSelector?, limit? }) → { pods[] }
- pods.get({ namespace, name }) → { metadata, status, containers[], initContainers[], events[] }
- pods.logs({ namespace, name, container?, tailLines?, sinceSeconds?, timestamps? }) → multiline text
- pods.exec({ namespace, name, container?, command[] }) [mutating] → { exitCode }

- resources.get({ group?, version, kind, name?, namespace?, labelSelector?, fieldSelector?, limit? }) → { item | items[] }
- resources.apply({ manifestYAML, fieldManager?, dryRun? }) [mutating] → { results[] }
- resources.delete({ group?, version, kind, name, namespace?, propagationPolicy?, gracePeriodSeconds?, dryRun? }) [mutating] → { status }

- secrets.get({ namespace, name, keys?, showValues? }) → { type, data }
- secrets.set({ namespace, name, data, type?, base64Encoded?, createIfMissing?, dryRun? }) [mutating] → { created|updated, name, keys }

Common gotchas
- 403/Forbidden: Your kube identity lacks RBAC. Fix roles/bindings.
- Big outputs: Use selectors and limit to keep responses small.
- Context confusion: Export K8S_CONTEXT or call cluster.setContext.

Extending safely
- Add new tools under internal/tools and register them in cmd/server.
- Enforce authz for any write path and default to dry-run.
- Keep responses compact and avoid logging sensitive data.
